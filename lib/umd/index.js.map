{"version":3,"file":"index.js","sources":["../node_modules/bbmn-utils/lib/es/index.js","router/build-route-context.js","router/action-context.js","router/process-callback.js","route-error-handler/index.js","router/router.js","pages/paged-app.js"],"sourcesContent":["import { BackboneView, BaseClass, Collection, MnObject, Model, Region, Router, extend, isClass, isCollection, isCollectionClass, isModel, isModelClass, isView, isViewClass } from 'bbmn-core';\nimport Mn from 'backbone.marionette';\n\nvar version = \"1.0.0\";\n\nvar ctors = _.reduce([Model, Collection, BackboneView, Router, MnObject, Region, BaseClass], function (ctors, ctor) {\n\t/* istanbul ignore next */\n\tif (_.isFunction(ctor)) {\n\t\tctors.push(ctor);\n\t}\n\treturn ctors;\n}, []);\n\nvar tryGetFromMn = ['Application', 'AppRouter'];\n\n_.each(tryGetFromMn, function (ClassName) {\n\t_.isFunction(Mn[ClassName]) && ctors.push(Mn[ClassName]);\n});\n\nfunction isKnownCtor(arg) {\n\tvar isFn = _.isFunction(arg);\n\tvar result = _(ctors).some(function (ctor) {\n\t\treturn arg === ctor || arg.prototype instanceof ctor;\n\t});\n\treturn isFn && result;\n}\n\nfunction betterResult() {\n\tvar obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\tvar key = arguments[1];\n\tvar opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\tvar context = opts.context,\n\t    args = opts.args,\n\t    checkAlso = opts.checkAlso,\n\t    force = opts.force;\n\n\tvar defaultValue = opts.default;\n\n\tif (!_.isString(key) || key === '') {\n\t\treturn;\n\t}\n\n\tvar value = obj[key];\n\n\tif (value != null && (!_.isFunction(value) || isKnownCtor(value))) {\n\t\treturn value;\n\t}\n\n\tif (force !== false && _.isFunction(value)) {\n\t\tvalue = value.apply(context || obj, args);\n\t}\n\n\t//let result = force !== false && _.isFunction(value) ? value.apply(context || obj, args) : value;\n\n\tif (value == null && _.isObject(checkAlso)) {\n\t\tvar alsoOptions = _.omit(opts, 'checkAlso');\n\t\tvalue = betterResult(checkAlso, key, alsoOptions);\n\t}\n\n\tif (value == null && defaultValue != null) {\n\t\tvalue = defaultValue;\n\t}\n\n\treturn value;\n}\n\n// camelCase('asd:qwe:zxc') -> asdQweZxc\n// camelCase('asd:qwe:zxc', true) -> AsdQweZxc\nfunction camelCase() {\n\n\tvar text = void 0;\n\tvar first = void 0;\n\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\tif (!args.length) return;else if (args.length == 1) {\n\t\ttext = args[0];\n\t} else {\n\t\tif (_.isBoolean(args[args.length - 1])) {\n\t\t\tfirst = args.pop();\n\t\t}\n\t\ttext = _.filter(args, function (chunk) {\n\t\t\treturn chunk != null;\n\t\t}).join(':');\n\t}\n\n\tif (!text) return text;\n\n\tif (!_.isString(text)) return text.toString();\n\ttext = text.replace(/:{2,}/gmi, ':');\n\tvar splitter = first === true ? /(^|:)(\\w)/gi : /(:)(\\w)/gi;\n\ttext = text.replace(splitter, function (match, prefix, text) {\n\t\treturn text.toUpperCase();\n\t});\n\tif (!first) text = text.replace(/(^)(\\w)/gi, function (match, prefix, text) {\n\t\treturn text.toLowerCase();\n\t});\n\treturn text;\n}\n\nfunction takeFirst(key) {\n\tif (!_.isString(key) || key === '') return;\n\tvar value = void 0;\n\n\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\targs[_key - 1] = arguments[_key];\n\t}\n\n\t_.some(args, function (arg) {\n\t\tif (!_.isObject(arg)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (key in arg) {\n\t\t\tvalue = arg[key];\n\t\t\treturn true;\n\t\t}\n\t});\n\treturn value;\n}\n\nfunction getModel(arg) {\n\n\tif (isModel(arg)) {\n\t\treturn arg;\n\t}\n\n\tif (isView(arg)) {\n\t\treturn arg.model;\n\t}\n}\n\nfunction getModel$1(arg) {\n\treturn isView(arg) && arg;\n}\n\nfunction compareAB(a, b, func) {\n\tif (_.isArray(func)) {\n\n\t\tvar result = 0;\n\n\t\t_(func).every(function (f) {\n\t\t\tresult = compareAB(a, b, f);\n\t\t\treturn result === 0;\n\t\t});\n\n\t\treturn result;\n\t} else {\n\t\tif (_.isFunction(func)) {\n\t\t\ta = func.call(a, getModel(a), getModel$1(a));\n\t\t\tb = func.call(b, getModel(b), getModel$1(b));\n\t\t}\n\n\t\tif (a < b) return -1;\n\t\tif (a > b) return 1;\n\t\treturn 0;\n\t}\n}\n\nvar toArray = function (arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction comparator() {\n\tvar result = 0;\n\n\t//for simple case (arg1, arg2, compare)\n\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\tif (args.length <= 3 && !_.isArray(args[0])) {\n\n\t\treturn compareAB.apply(null, args);\n\t}\n\t//for complex cases ([arg1, arg2, compare], [], .... [])\n\t//each arguments should be an array\n\telse {\n\n\t\t\t_(args).every(function (single) {\n\n\t\t\t\tif (!_.isArray(single)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tresult = compareAB.apply(undefined, toConsumableArray(single));\n\t\t\t\treturn result === 0;\n\t\t\t});\n\t\t}\n\n\treturn result;\n}\n\nfunction toNumber(text) {\n\n\tif (_.isNumber(text) && !_.isNaN(text)) {\n\t\treturn text;\n\t} else if (text == null || !_.isString(text)) {\n\t\treturn;\n\t}\n\n\tvar value = parseFloat(text, 10);\n\n\tif (isNaN(value)) {\n\t\treturn;\n\t}\n\n\treturn value;\n}\n\nvar defaultOptions = {\n\tnullable: true,\n\tstrict: false,\n\treturnNullAs: undefined,\n\treturnEmptyAs: undefined,\n\treturnNullAndEmptyAs: undefined,\n\treturnAnyAs: undefined,\n\treturnOtherAs: undefined\n};\n\nvar trueValues = ['true', '1', '-1', 'yes'];\nvar falseValues = ['false', '0', 'no'];\n\nvar alternative = function alternative() {\n\tvar returnValue = void 0;\n\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\t_(args).some(function (arg) {\n\t\tif (_.isBoolean(arg)) {\n\t\t\treturnValue = arg;\n\t\t\treturn true;\n\t\t}\n\t});\n\treturn returnValue;\n};\n\nvar valueOrAlternative = function valueOrAlternative(nullable, nullValue, value) {\n\tfor (var _len2 = arguments.length, alts = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t\talts[_key2 - 3] = arguments[_key2];\n\t}\n\n\tvar alt = alternative.apply(undefined, alts);\n\tif (alt != null) return alt;else if (nullable) return nullValue;else return value;\n};\n\nvar convertToBoolean = function convertToBoolean(arg) {\n\tvar opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n\tvar other = void 0;\n\tvar options = _.extend({}, defaultOptions, opts);\n\tvar nullable = options.nullable,\n\t    strict = options.strict,\n\t    returnNullAs = options.returnNullAs,\n\t    returnEmptyAs = options.returnEmptyAs,\n\t    returnNullAndEmptyAs = options.returnNullAndEmptyAs,\n\t    returnAnyAs = options.returnAnyAs,\n\t    returnOtherAs = options.returnOtherAs;\n\n\n\tif (arg == null) {\n\t\treturn valueOrAlternative(nullable, undefined, false, returnNullAs, returnNullAndEmptyAs);\n\t} else if (arg === '') {\n\t\treturn valueOrAlternative(nullable, undefined, false, returnEmptyAs, returnNullAndEmptyAs);\n\t} else if (_.isBoolean(arg)) {\n\t\treturn arg;\n\t}\n\t//  else if (_.isObject(arg)) {\n\t// }\n\n\tother = strict ? nullable ? undefined : false : true;\n\n\tvar text = arg.toString().toLowerCase();\n\tvar isTrue = convertToBoolean.trueValues.indexOf(text) > -1;\n\tvar isFalse = convertToBoolean.falseValues.indexOf(text) > -1;\n\n\tif (_.isBoolean(returnAnyAs)) {\n\t\treturn returnAnyAs;\n\t} else if (_.isBoolean(returnOtherAs)) {\n\t\tother = returnOtherAs;\n\t}\n\n\treturn isTrue ? true : isFalse ? false : other;\n};\n\nconvertToBoolean.trueValues = trueValues;\nconvertToBoolean.falseValues = falseValues;\n\nvar converters = {\n\tnumber: toNumber,\n\tboolean: convertToBoolean,\n\tbool: convertToBoolean\n};\n\n//this is under development yet and can be change in any time\nfunction convertString(text, type, opts) {\n\n\tif (!_.isString(type)) {\n\t\tthrow new Error('type should be a string');\n\t}\n\n\tvar converter = converters[type];\n\n\tif (!_.isFunction(converter)) {\n\t\tthrow new Error('string converter ' + type + ' is not a function');\n\t}\n\n\treturn converter(text, opts);\n}\n\nvar privateApi = {\n\ttraverse: function traverse(source) {\n\t\tvar destination = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\tvar root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n\n\t\tif (!_.isObject(source) || source === global) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar hash = isModel(source) ? source.attributes : source;\n\n\t\tvar props = Object.getOwnPropertyNames(hash);\n\n\t\tfor (var x = 0; x < props.length; x++) {\n\t\t\tvar name = props[x];\n\t\t\tvar prop = hash[name];\n\t\t\tif (prop === undefined) {\n\t\t\t\tcontinue;\n\t\t\t} else if (_.isArray(prop)) {\n\t\t\t\tdestination[root + name] = prop.slice(0);\n\t\t\t} else if (_.isDate(prop)) {\n\t\t\t\tdestination[root + name] = new Date(prop.valueOf());\n\t\t\t} else if (!_.isObject(prop)) {\n\t\t\t\tdestination[root + name] = prop;\n\t\t\t} else {\n\t\t\t\tprivateApi.traverse(prop, destination, root + name + '.');\n\t\t\t}\n\t\t}\n\n\t\treturn destination;\n\t}\n};\n\nfunction flattenObject(obj) {\n\tif (_.isObject(obj)) {\n\t\treturn privateApi.traverse(obj);\n\t}\n}\n\nfunction getProperty(context, name) {\n\tif (context == null || !_.isObject(context) || name == null || name == '') return;\n\tif (isModel(context)) return context.get(name, { gettingByPath: true });else return context[name];\n}\n\nfunction getByPathArray(context, propertyName, pathArray) {\n\n\tif (context == null || !_.isObject(context) || propertyName == null || propertyName == '') return;\n\n\tvar prop = getProperty(context, propertyName);\n\n\tif (!pathArray.length || pathArray.length && prop == null) return prop;\n\n\tvar nextName = pathArray.shift();\n\n\treturn getByPathArray(prop, nextName, pathArray);\n}\n\nfunction getByPath(obj, path) {\n\n\tif (obj == null || !_.isObject(obj) || path == null || path == '') return;\n\n\tvar pathArray = _.isString(path) ? path.split('.') : _.isArray(path) ? [].slice.call(path) : [path];\n\n\tvar prop = pathArray.shift();\n\n\treturn getByPathArray(obj, prop, pathArray);\n}\n\nfunction getOption() {\n\tvar context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\tvar key = arguments[1];\n\tvar opts = arguments[2];\n\tvar also = arguments[3];\n\n\n\tif (_.isObject(key) && _.isString(opts)) {\n\t\tvar _opts = also;\n\t\talso = key;\n\t\tkey = opts;\n\t\topts = _opts;\n\t}\n\n\tvar options = _.extend({ args: [context], context: context }, opts, { default: null });\n\tvar deep = options.deep;\n\n\tvar defaultValue = opts && opts.default;\n\n\tvar value = betterResult(context.options || also, key, options);\n\tif (value == null && deep !== false) {\n\t\tvalue = betterResult(context, key, options);\n\t}\n\n\treturn value != null ? value : defaultValue;\n}\n\nfunction instanceGetOption() {\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\treturn getOption.apply(undefined, [this].concat(args));\n}\n\nfunction isEmptyValue(arg) {\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$allowWhiteSpace = _ref.allowWhiteSpace,\n\t    allowWhiteSpace = _ref$allowWhiteSpace === undefined ? false : _ref$allowWhiteSpace;\n\n\tif (arg == null || _.isNaN(arg)) return true;\n\n\tif (!_.isString(arg)) return false;\n\n\tif (arg === '') return true;\n\n\treturn !allowWhiteSpace && arg.trim() === '';\n}\n\nfunction normalizeStringArray(arr) {\n\treturn _.reduce(arr, function (result, item) {\n\n\t\tif (isEmptyValue(item)) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult.push(item.toString());\n\t\treturn result;\n\t}, []);\n}\n\nfunction normalizeArgument(value, options, returnObject) {\n\n\tif (_.isString(value)) {\n\t\tvalue = value.split(/\\s*,\\s*/gmi);\n\t}\n\n\tif (_.isArray(value)) {\n\t\treturn normalizeStringArray(value, options);\n\t} else if (_.isObject(value) && returnObject) {\n\t\treturn value;\n\t}\n}\n\nfunction normalizeValueAndFlag(value, flag, options) {\n\treturn {\n\t\tvalues: normalizeArgument(value, options, true),\n\t\tflags: normalizeArgument(flag, options)\n\t};\n}\n\nfunction compare(a, b, _ref) {\n\tvar caseSensitive = _ref.caseSensitive;\n\n\n\tif (!caseSensitive) {\n\t\ta = a.toLowerCase();\n\t\tb = b.toLowerCase();\n\t}\n\n\treturn a === b;\n}\n\nfunction searchFlags(values, flags, options) {\n\tvar isArray = _.isArray(values);\n\tvar useObjectValues = options.useObjectValues;\n\n\n\tvar result = _.reduce(values, function (filtered, item, key) {\n\t\tvar check = item;\n\t\tif (!isArray && !useObjectValues) {\n\t\t\tcheck = key;\n\t\t}\n\n\t\tvar good = _.some(flags, function (flag) {\n\t\t\treturn compare(check, flag, options);\n\t\t});\n\n\t\tif (!good) {\n\t\t\treturn filtered;\n\t\t}\n\n\t\tif (isArray) {\n\t\t\tfiltered.push(check);\n\t\t} else {\n\t\t\tfiltered.push({ value: item, key: key });\n\t\t}\n\n\t\treturn filtered;\n\t}, []);\n\n\tvar all = options.all;\n\tif (!result.length || all && result.length != values.length) {\n\t\treturn;\n\t}\n\n\treturn result;\n}\n\nvar processReturns = {\n\tstring: function string(_ref) {\n\t\tvar isArray = _ref.isArray,\n\t\t    founded = _ref.founded,\n\t\t    delimeter = _ref.delimeter,\n\t\t    takeObjectKeys = _ref.takeObjectKeys;\n\n\t\tif (isArray) {\n\t\t\treturn founded.join(delimeter);\n\t\t} else {\n\t\t\tvar key = takeObjectKeys ? 'key' : 'value';\n\t\t\treturn _.pluck(founded, key).join(delimeter);\n\t\t}\n\t},\n\tarray: function array(_ref2) {\n\t\tvar isArray = _ref2.isArray,\n\t\t    doNotPluck = _ref2.doNotPluck,\n\t\t    founded = _ref2.founded,\n\t\t    takeObjectKeys = _ref2.takeObjectKeys;\n\n\t\tif (isArray || doNotPluck) {\n\t\t\treturn founded;\n\t\t} else {\n\t\t\tvar key = takeObjectKeys ? 'key' : 'value';\n\t\t\treturn _.pluck(founded, key);\n\t\t}\n\t},\n\tobject: function object(_ref3) {\n\t\tvar isArray = _ref3.isArray,\n\t\t    takeObjectKeys = _ref3.takeObjectKeys,\n\t\t    founded = _ref3.founded;\n\n\t\treturn _.reduce(founded, function (result, item, index) {\n\t\t\tvar value = isArray ? item : takeObjectKeys ? item.key : item.value;\n\t\t\tvar key = isArray ? index : takeObjectKeys ? item.value : item.key;\n\t\t\tresult[key] = value;\n\t\t\treturn result;\n\t\t}, {});\n\t}\n};\n\nfunction normalizedReturn(_ref4) {\n\tvar returnAs = _ref4.returnAs,\n\t    flag = _ref4.flag,\n\t    isArray = _ref4.isArray,\n\t    founded = _ref4.founded,\n\t    delimeter = _ref4.delimeter,\n\t    takeObjectKeys = _ref4.takeObjectKeys,\n\t    doNotPluck = _ref4.doNotPluck;\n\n\tif (returnAs == null) {\n\t\treturnAs = _.isArray(flag) ? 'array' : 'string';\n\t}\n\tvar processor = processReturns[returnAs];\n\tif (!_.isFunction(processor)) {\n\t\treturn;\n\t}\n\n\tvar processorOptions = {\n\t\tisArray: isArray, founded: founded, delimeter: delimeter, takeObjectKeys: takeObjectKeys, doNotPluck: doNotPluck\n\t};\n\n\treturn processor(processorOptions);\n}\n\nfunction getFlag(value, flag) {\n\tvar options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\tvar _normalizeValueAndFla = normalizeValueAndFlag(value, flag, options),\n\t    flags = _normalizeValueAndFla.flags,\n\t    values = _normalizeValueAndFla.values;\n\n\tif (!flags || !values) {\n\t\treturn;\n\t}\n\n\tvar founded = searchFlags(values, flags, options);\n\tif (!founded) {\n\t\treturn;\n\t}\n\n\tvar returnOptions = _.extend({\n\t\tdelimeter: ', ',\n\t\tisArray: _.isArray(values),\n\t\tflag: flag,\n\t\tfounded: founded\n\t}, _.pick(options, 'returnAs', 'takeObjectKeys', 'doNotPluck'));\n\n\treturn normalizedReturn(returnOptions);\n}\n\nfunction hasFlag(value, flag) {\n\tvar options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\n\tif (value == null || flag == null) return false;\n\n\tif (_.isNumber(value)) {\n\n\t\tif (!_.isNumber(flag)) return false;\n\n\t\tvar has = value & flag;\n\t\treturn options.all === true ? has === flag : has > 0;\n\t}\n\n\tvar _normalizeValueAndFla = normalizeValueAndFlag(value, flag, options),\n\t    flags = _normalizeValueAndFla.flags,\n\t    values = _normalizeValueAndFla.values;\n\n\tif (!flags || !values) {\n\t\treturn false;\n\t}\n\n\tvar founded = searchFlags(values, flags, options);\n\treturn !!founded && !!founded.length;\n}\n\nvar defaultOptions$1 = {\n\tmergeObjects: true,\n\twrapObjectWithConstructor: true\n};\n\nfunction createMixinFromObject(arg) {\n\n\tvar mixedObj = _.clone(arg);\n\tvar ctor = mixedObj.hasOwnProperty('constructor') && _.isFunction(mixedObj.constructor) && mixedObj.constructor;\n\tvar hasConstructor = _.isFunction(ctor);\n\n\treturn function (Base) {\n\t\tif (hasConstructor) {\n\t\t\tmixedObj.constructor = function mx() {\n\t\t\t\tBase.apply(this, arguments);\n\t\t\t\tctor.apply(this, arguments);\n\t\t\t};\n\t\t}\n\t\treturn Base.extend(mixedObj);\n\t};\n}\n\nfunction normalizeArguments(args, opts) {\n\tvar raw = {};\n\tvar wrap = opts.wrapObjectWithConstructor == true;\n\tvar merge = opts.mergeObjects == true;\n\tvar mixins = [];\n\t_(args).each(function (arg) {\n\n\t\t//if argument is function just put it to mixins array\n\t\t//and continue;\n\t\tif (_.isFunction(arg)) {\n\t\t\tmixins.push(arg);\n\t\t\treturn;\n\t\t}\n\n\t\t//if argument is not an object just skip it\n\t\tif (!_.isObject(arg)) return;\n\n\t\t//if mergeObjects == false or wrapObjectWithConstructor == true \n\t\t//and there is a constructor function\n\t\t//converting to a mixin function\n\t\t//otherwise extend rawObject\n\t\tif (!merge || wrap && _.isFunction(arg.constructor)) {\n\t\t\tmixins.push(createMixinFromObject(arg));\n\t\t} else {\n\t\t\t_.extend(raw, arg);\n\t\t}\n\t});\n\n\t//if rawObject is not empty\n\t//convert it to a mixin function\n\t//and put it to the begin of mixins array\n\tif (_.size(raw)) mixins.unshift(createMixinFromObject(raw));\n\n\treturn mixins;\n}\n\nfunction withMethod() {\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\tvar mixins = normalizeArguments(args, this.options);\n\tvar Mixed = this.class;\n\tif (!mixins.length) {\n\t\treturn Mixed;\n\t} else {\n\t\treturn _.reduce(mixins, function (Memo, Ctor) {\n\t\t\tvar mixed = Ctor(Memo);\n\t\t\treturn mixed;\n\t\t}, Mixed);\n\t}\n}\n\nfunction mix(_ctor, options) {\n\n\tvar opts = _.extend({}, defaultOptions$1, options);\n\n\tvar ctor = void 0;\n\n\tif (_.isFunction(_ctor)) {\n\t\tctor = _ctor;\n\t} else if (_.isObject(_ctor)) {\n\t\tvar b = _.isFunction(_ctor.constructor) && _ctor.constructor;\n\t\tctor = function mx() {\n\t\t\tb.apply(this, arguments);\n\t\t};\n\t\t_.extend(ctor.prototype, _.omit(_ctor, 'constructor'));\n\t} else {\n\t\tthrow new Error('Mix argument should be a class or a plain object');\n\t}\n\n\tif (!_.isFunction(ctor.extend)) {\n\t\tctor.extend = extend;\n\t}\n\n\treturn {\n\t\toptions: opts,\n\t\twith: withMethod,\n\t\tclass: ctor\n\t};\n}\n\nfunction pstoSetPair(context, pair, options) {\n\tif (!_.isString(pair) || pair === '') return;\n\n\tvar keyvalue = pair.split('=');\n\tvar key = keyvalue.shift();\n\tvar value = keyvalue.join('=');\n\tpstoSetKeyValue(context, key, value, options);\n}\n\nfunction pstoSetKeyValue(context, key, value, options) {\n\n\tif (isEmptyValue(key) || isEmptyValue(value)) return;\n\n\tkey = decodeURIComponent(key);\n\tvalue = decodeURIComponent(value);\n\n\tvar transform = options.transform;\n\tif (_.isFunction(transform)) {\n\t\tvalue = transform(key, value, options);\n\t}\n\n\tif (!(key in context)) {\n\t\tcontext[key] = value;\n\t\treturn value;\n\t}\n\n\tif (!_.isArray(context[key])) {\n\t\tcontext[key] = [context[key]];\n\t}\n\n\tcontext[key].push(value);\n\n\treturn context[key];\n}\n\nfunction paramsToObject(raw) {\n\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\tvar emptyObject = options.emptyObject !== false;\n\tvar result = {};\n\tif (!_.isString(raw)) return emptyObject ? result : raw;\n\n\tvar pairs = raw.split('&');\n\t_(pairs).each(function (pair) {\n\t\treturn pstoSetPair(result, pair, options);\n\t});\n\n\tif (!_.size(result) && !emptyObject) {\n\t\treturn raw;\n\t}\n\n\treturn result;\n}\n\nfunction setProperty(context, name, value) {\n\tif (isModel(context)) {\n\t\tcontext.set(name, value, { silent: true });\n\t} else {\n\t\tcontext[name] = value;\n\t}\n\n\treturn getProperty(context, name);\n}\n\nfunction setByPathArr(context, propertyName, pathArray, value, options) {\n\n\tvar modelContext = void 0;\n\tif (isModel(context)) {\n\t\tmodelContext = {\n\t\t\tmodel: context,\n\t\t\tproperty: propertyName,\n\t\t\tpathChunks: [].slice.call(pathArray)\n\t\t};\n\t}\n\n\t//set value if this is a last chunk of path\n\tif (!pathArray.length) {\n\n\t\tmodelContext && options.models.push(modelContext);\n\n\t\treturn {\n\t\t\tvalue: setProperty(context, propertyName, value, options)\n\t\t};\n\t} else {\n\n\t\tvar prop = getProperty(context, propertyName);\n\n\t\tif (!_.isObject(prop) && !options.force) {\n\t\t\treturn;\n\t\t} else if (!_.isObject(prop) && options.force) {\n\t\t\tprop = setProperty(context, propertyName, {}, options);\n\t\t}\n\n\t\tmodelContext && options.models.push(modelContext);\n\n\t\tvar nextName = pathArray.shift();\n\n\t\treturn setByPathArr(prop, nextName, pathArray, value, options);\n\t}\n}\n\nfunction normalizeSetByPathOptions() {\n\tvar opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\tvar ext = arguments[1];\n\tvar silent = opts.silent,\n\t    force = opts.force;\n\n\tsilent = silent === true;\n\tforce = force !== false;\n\tvar options = _.extend({}, opts, ext, {\n\t\tsilent: silent, force: force,\n\t\tmodels: []\n\t});\n\n\treturn options;\n}\n\nfunction triggerModelEventsOnSetByPath(value, options) {\n\tif (options.silent || !options.models.length) {\n\t\treturn;\n\t}\n\n\t_(options.models).each(function (context) {\n\t\tvar rest = context.pathChunks.join(':');\n\t\tif (rest) {\n\t\t\tcontext.model.trigger('change:' + context.property + ':' + rest, context.model, value);\n\t\t}\n\t\tcontext.model.trigger('change:' + context.property, context.model, value);\n\t\tcontext.model.trigger('change', context.model);\n\t});\n}\n\nfunction ensureSetByPathArguments(context, path) {\n\tvar errors = [];\n\tif (!_.isObject(context)) {\n\t\terrors.push(new Error('Context is not an object'));\n\t}\n\tif (!_.isString(path) || path === '') {\n\t\terrors.push(new Error('Path is not a string'));\n\t}\n\tif (errors.length) {\n\t\treturn errors;\n\t}\n}\n\nfunction setByPath(context, path, value, opts) {\n\n\tvar argumentsErrors = ensureSetByPathArguments(context, path);\n\tif (argumentsErrors) {\n\t\treturn value;\n\t}\n\n\tvar pathArray = path.split('.');\n\tvar options = normalizeSetByPathOptions(opts, { path: path, pathArray: [].slice.call(pathArray) });\n\n\tvar propertyName = pathArray.shift();\n\n\tvar result = setByPathArr(context, propertyName, pathArray, value, options);\n\tif (result === undefined) {\n\t\treturn value;\n\t} else {\n\t\ttriggerModelEventsOnSetByPath(value, options);\n\t\treturn result.value;\n\t}\n}\n\nfunction unFlat(obj) {\n\n\tif (obj == null || !_.isObject(obj)) return;\n\tvar res = {};\n\tfor (var e in obj) {\n\t\tsetByPath(res, e, obj[e]);\n\t}\n\treturn res;\n}\n\nfunction check(arg, opts) {\n\topts.ob += _.isObject(arg) && 1 || 0;\n\topts.ar += _.isArray(arg) && 1 || 0;\n\topts.fn += _.isFunction(arg) && 1 || 0;\n\topts.sum += opts.ob + opts.ar + opts.fn;\n}\n\nfunction checkArguments(a, b) {\n\tvar chck = { ob: 0, ar: 0, fn: 0, sum: 0 };\n\tcheck(a, chck);\n\tcheck(b, chck);\n\treturn [chck.sum, chck.ob, chck.fn, chck.ar];\n}\n\nfunction compareObjects(objectA, objectB) {\n\tvar _checkArguments = checkArguments(objectA, objectB),\n\t    _checkArguments2 = toArray(_checkArguments),\n\t    sum = _checkArguments2[0],\n\t    vals = _checkArguments2.slice(1);\n\n\tif (sum === 0) {\n\t\treturn objectA == objectB;\n\t}\n\tif (!_.every(vals, function (val) {\n\t\treturn val % 2 === 0;\n\t})) {\n\t\treturn false;\n\t}\n\n\tvar size = _.size(objectA);\n\tif (size != _.size(objectB)) {\n\t\treturn false;\n\t}\n\n\tif (_.isArray(objectA)) {\n\t\tvar allvalues = _.uniq(objectA.concat(objectB));\n\t\treturn _.every(allvalues, function (value) {\n\t\t\tvar valuesA = _.filter(objectA, function (_v) {\n\t\t\t\treturn compareObjects(_v, value);\n\t\t\t});\n\t\t\tvar valuesB = _.filter(objectB, function (_v) {\n\t\t\t\treturn compareObjects(_v, value);\n\t\t\t});\n\t\t\tif (valuesA.length != valuesB.length) return false;\n\t\t\treturn compareObjects(valuesA[0], valuesB[0]);\n\t\t});\n\t} else {\n\t\tvar allkeys = _.uniq(_.keys(objectA).concat(_.keys(objectB)));\n\t\tif (allkeys.length != size) return false;\n\t\treturn _.every(allkeys, function (key) {\n\t\t\treturn compareObjects(objectA[key], objectB[key]);\n\t\t});\n\t}\n}\n\nfunction triggerMethodOn(context) {\n\tif (!_.isObject(context)) {\n\t\treturn;\n\t}\n\n\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\targs[_key - 1] = arguments[_key];\n\t}\n\n\treturn triggerMethod.call.apply(triggerMethod, [context].concat(args));\n}\n\nfunction triggerMethod(event) {\n\tfor (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t\targs[_key2 - 1] = arguments[_key2];\n\t}\n\n\t// get the method name from the event name\n\tvar methodName = camelCase('on:' + event);\n\tvar method = getOption(this, methodName, { force: false });\n\tvar result = void 0;\n\n\t// call the onMethodName if it exists\n\tif (_.isFunction(method)) {\n\t\t// pass all args, except the event name\n\t\tresult = method.apply(this, args);\n\t}\n\n\tif (_.isFunction(this.trigger)) {\n\t\t// trigger the event\n\t\tthis.trigger.apply(this, arguments);\n\t}\n\n\treturn result;\n}\n\nfunction mergeOptions(options) {\n\tvar _this = this;\n\n\tfor (var _len = arguments.length, keys = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\tkeys[_key - 1] = arguments[_key];\n\t}\n\n\tif (!_.isObject(options)) {\n\t\treturn;\n\t}\n\n\tkeys = _.flatten(keys);\n\n\treturn _.reduce(keys, function (merged, key) {\n\t\tif (!_.isString(key)) {\n\t\t\treturn merged;\n\t\t}\n\t\tvar option = options[key];\n\n\t\tif (option !== undefined) {\n\t\t\t_this[key] = option;\n\t\t\tmerged[key] = option;\n\t\t}\n\n\t\treturn merged;\n\t}, {});\n}\n\nfunction buildViewByKey(context, key) {\n\tvar _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t    TextView = _ref.TextView,\n\t    options = _ref.options;\n\n\tif (!_.isString(key)) {\n\t\treturn;\n\t}\n\n\tvar view = getOption(context, key, { args: [context] });\n\tvar _options = getOption(context, key + 'Options', { args: [context] });\n\n\tif (TextView && _.isString(view)) {\n\t\t_options = _.extend({}, _options, { text: view });\n\t\tview = TextView;\n\t}\n\toptions = _.extend({}, options, _options);\n\n\tif (isView(view)) {\n\t\treturn view;\n\t} else if (isViewClass(view)) {\n\t\treturn new view(options);\n\t}\n}\n\n// import getFlag from '../get-flag/index.js';\n// import hasFlag from '../has-flag/index.js';\nvar enumsStore = {};\n\nvar enumsApi = {\n\tgetFlag: getFlag,\n\thasFlag: hasFlag,\n\tgetByPath: getByPath,\n\tsetByPath: setByPath,\n\textendStore: function extendStore(hash) {\n\t\t_.extend(enumsStore, hash);\n\t},\n\tgetEnum: function getEnum(arg) {\n\t\tif (_.isObject(arg)) {\n\t\t\treturn arg;\n\t\t} else if (isEmptyValue(arg) || !_.isString(arg)) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn enumsApi.getByPath(enumsStore, arg);\n\t}\n};\n\nfunction get$1(arg, flag, options) {\n\tif (arguments.length === 0) {\n\t\treturn enumsStore;\n\t}\n\n\tvar _enum = enumsApi.getEnum(arg);\n\tif (arguments.length === 1) {\n\t\treturn _enum;\n\t}\n\n\treturn enumsApi.getFlag(_enum, flag, options);\n}\n\nfunction has(arg, flag, options) {\n\tvar _enum = enumsApi.getEnum(arg);\n\treturn enumsApi.hasFlag(_enum, flag, options);\n}\n\nvar enums = {\n\tget: get$1,\n\thas: has,\n\tset: function set(name, hash) {\n\t\tif (_.isString(name)) {\n\t\t\tenumsApi.setByPath(enumsStore, name, hash);\n\t\t} else if (_.isObject(name)) {\n\t\t\tenumsApi.extendStore(name);\n\t\t}\n\t}\n};\n\nfunction skipTake(array, take) {\n\tvar skip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\n\tif (!_.isObject(array)) {\n\t\treturn;\n\t}\n\n\tif (!_.isNumber(take) || !_.isNumber(skip)) {\n\t\tthrow new Error('skipTake skip and take arguments must be a numbers');\n\t}\n\n\tif (!_.isArray(array)) {\n\t\tarray = _.toArray(array);\n\t}\n\n\tvar length = take + skip;\n\tif (array.length < length) {\n\t\tlength = array.length;\n\t}\n\tvar taken = [];\n\tfor (var x = skip; x < length; x++) {\n\t\ttaken.push(array[x]);\n\t}\n\treturn taken;\n}\n\nfunction norm(arg) {\n\treturn _.isObject(arg) ? arg : {};\n}\n\nfunction mergeObjects$$1() {\n\tfor (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {\n\t\tobjects[_key] = arguments[_key];\n\t}\n\n\tvar flatted = _.reduce(objects, function (dest, item) {\n\t\t_.extend(dest, flattenObject(norm(item)));\n\t\treturn dest;\n\t}, {});\n\n\treturn unFlat(flatted);\n}\n\nvar index$1 = {\n\tVERSION: version,\n\tbetterResult: betterResult,\n\tcamelCase: camelCase,\n\ttakeFirst: takeFirst,\n\tcomparator: comparator,\n\tcompareAB: compareAB,\n\tconvertString: convertString,\n\ttoNumber: toNumber,\n\textend: extend,\n\tflat: flattenObject,\n\tgetByPath: getByPath,\n\tgetOption: getOption,\n\tinstanceGetOption: instanceGetOption,\n\thasFlag: hasFlag, getFlag: getFlag,\n\tisKnownCtor: isKnownCtor,\n\tknownCtors: ctors,\n\tisEmptyValue: isEmptyValue,\n\tmix: mix,\n\tparamsToObject: paramsToObject,\n\tsetByPath: setByPath,\n\ttoBool: convertToBoolean,\n\tunflat: unFlat,\n\tcompareObjects: compareObjects,\n\tmergeObjects: mergeObjects$$1,\n\ttriggerMethod: triggerMethod,\n\ttriggerMethodOn: triggerMethodOn,\n\tmergeOptions: mergeOptions,\n\tbuildViewByKey: buildViewByKey,\n\tenums: enums, enumsStore: enumsStore,\n\tskipTake: skipTake,\n\tisClass: isClass, isModel: isModel, isModelClass: isModelClass, isCollection: isCollection, isCollectionClass: isCollectionClass, isView: isView, isViewClass: isViewClass\n};\n\nexport { version as VERSION, betterResult, camelCase, takeFirst, comparator, compareAB, convertString, toNumber, extend, flattenObject as flat, getByPath, getOption, instanceGetOption, hasFlag, getFlag, isKnownCtor, ctors as knownCtors, isEmptyValue, mix, paramsToObject, setByPath, convertToBoolean as toBool, unFlat as unflat, compareObjects, mergeObjects$$1 as mergeObjects, triggerMethod, triggerMethodOn, mergeOptions, buildViewByKey, enums, enumsStore, skipTake, isClass, isModel, isModelClass, isCollection, isCollectionClass, isView, isViewClass };\nexport default index$1;\n\n//# sourceMappingURL=index.js.map\n","import { betterResult as result } from 'bbmn-utils';\r\n\r\nfunction get(router, opts = {}, key, update){\r\n\t\r\n\tlet value = result(opts, key, { context: router, args:[ router ] });\r\n\tif(value == null) {\r\n\t\tvalue = router.getOption(key, {args: [ router ]});\r\n\t\tif(update)\r\n\t\t\topts[key] = value;\r\n\t}\r\n\treturn value;\t\t\r\n}\r\n\r\n// converts route method arguments to plain object;\r\n// _normalizeRegisterRouteArguments\r\n// { route, rawRoute, callback, name }\r\nexport default function routeArgumentsToObject(router, route, name, callback, opts = {}){\r\n\r\n\tlet context = {};\r\n\r\n\tif(_.isObject(route)){\r\n\t\tcontext = route;\r\n\r\n\t\t//then second argument is probably options;\r\n\t\t_.extend(opts, name);\r\n\r\n\t} else if (_.isFunction(name)) {\r\n\t\t_.extend(context, { route, callback: name, name: _.uniqueId('routerAction') });\r\n\t} else {\r\n\t\t_.extend(context, { route, name, callback });\r\n\t}\r\n\r\n\tlet isRouterHoldsActions = get(router, opts, 'isRouterHoldsActions', true);\r\n\r\n\r\n\t// last chance to get callback from router instance by name\r\n\t// this behavior can be disabled through `isRouterHoldsActions` options\r\n\tif(!_.isFunction(context.callback) && isRouterHoldsActions && _.isFunction(router[context.name])) {\r\n\r\n\t\tcontext.callback = router[context.name];\r\n\r\n\t}\r\n\r\n\t//store original route\r\n\tcontext.rawRoute = context.route;\r\n\r\n\t!context.name && (context.name = _.uniqueId('routerAction'));\r\n\r\n\t//converts route to RegExp pattern\r\n\tif (!_.isRegExp(context.route)) context.route = router._routeToRegExp(context.route);\r\n\r\n\t// by default backbone router wraps every callback with own wrapper\r\n\t// which in turn call actual callback with correct arguments on route\r\n\t// this callback was inlined and can not be overrided, so now its possible\t\r\n\tcontext.callbackWrapper = _.bind(router._processCallback, router, context);\r\n\r\n\treturn context;\r\n}\r\n\r\n\r\n\r\n","export function createActionContext(router, routeContext, fragment, options = {}) {\r\n\r\n\tlet rawArgs = router._extractParameters(routeContext.route, fragment);\r\n\r\n\tlet result = _.extend({}, routeContext, { fragment, rawArgs }, options, { options });\r\n\r\n\tlet args = rawArgs.slice(0);\r\n\tlet queryString = args.pop();\r\n\r\n\t_.extend(result, { qs: prepareActionQueryString(router, queryString) });\r\n\t_.extend(result, { args: prepareActionArguments(routeContext.rawRoute, args) });\r\n\r\n\tif (result.routeType == null) {\r\n\t\tresult.routeType = 'route';\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction prepareActionQueryString(router, queryString){\r\n\tif(_.isString(queryString))\r\n\t\treturn router.queryStringParser(queryString);\r\n\telse\r\n\t\treturn {};\r\n}\r\n\r\nfunction prepareActionArguments(rawRoute, args){\r\n\r\n\tlet params = rawRoute.match(/:([^/|)]+)/g) || [];\r\n\t\r\n\tlet res = {};\r\n\t_(params).each((name, index) => {\r\n\t\tname = name.substring(1);\r\n\t\t\r\n\t\tif(args == null) return;\r\n\r\n\t\tif(name in res && _.isArray(res[name]))\r\n\t\t\tres[name].push(args[index]);\r\n\t\telse if(name in res && !_.isArray(res[name]))\r\n\t\t\tres[name] = [res[name]].concat(args[index]);\r\n\t\telse\r\n\t\t\tres[name] = args[index];\r\n\t});\r\n\treturn res;\r\n}\r\n","\r\nfunction toPromise(arg, resolve = true){\r\n\tif (arg instanceof Promise || (arg && _.isFunction(arg.then)))\r\n\t\treturn arg;\r\n\telse if (arg instanceof Error)\r\n\t\treturn Promise.reject(arg);\r\n\telse\r\n\t\treturn resolve \r\n\t\t\t? Promise.resolve(arg) \r\n\t\t\t: Promise.reject(arg);\r\n}\r\n\r\n\r\nfunction getCallbackFunction(callback, executeResult)\r\n{\r\n\treturn (...args) => {\r\n\t\ttry {\r\n\t\t\texecuteResult.value = callback && callback(...args);\r\n\t\t} catch(exception) {\r\n\t\t\texecuteResult.value = exception;\r\n\t\t}\r\n\t\texecuteResult.promise = toPromise(executeResult.value);\r\n\t\treturn executeResult.value;\r\n\t};\r\n}\r\n\r\n\r\nexport function processCallback(router, actionContext, routeType){\t\r\n\t\r\n\tlet args = router.getOption('classicMode') \r\n\t\t? actionContext.rawArgs || [] \r\n\t\t: [ actionContext ];\r\n\r\n\tlet asPromise = router.getOption('callbackAsPromises');\r\n\tlet executeResult = {};\r\n\tlet callback = getCallbackFunction(actionContext.callback, executeResult, asPromise);\r\n\r\n\r\n\t\r\n\trouter.triggerEvent('before:' + routeType, actionContext);\r\n\r\n\tlet shouldTriggerEvent = router.execute(callback, args);\r\n\tif (shouldTriggerEvent !== false) {\r\n\t\trouter.triggerEvent(routeType, actionContext);\r\n\t\tif(routeType == 'route' || routeType == 'backroute')\r\n\t\t\trouter.lastAttempt = actionContext;\r\n\t}\r\n\r\n\texecuteResult.promise.then(\r\n\t\t(arg) => {\r\n\t\t\trouter.triggerEvent('after:'+routeType, actionContext);\r\n\t\t\treturn arg;\r\n\t\t},\r\n\t\t(error) => {\r\n\t\t\trouter.triggerEvent('error:' + routeType, error, actionContext);\r\n\t\t\trouter.handleError(error, actionContext);\r\n\t\t}\r\n\t);\r\n\r\n\treturn executeResult.value;\r\n}\r\n\r\n\r\n\r\n","import $ from 'jquery';\r\n\r\nexport default {\r\n\thandlers: {\r\n\t\t'js:error'(error){\r\n\t\t\tthrow error;\r\n\t\t},\r\n\t},\r\n\thandle(error, context, args){\r\n\r\n\t\tlet handlers = this._getHandleContext(error, context, args) || {};\r\n\t\treturn _(handlers).some((options, key) => this.applyHandler(key, options));\r\n\r\n\t},\r\n\tapplyHandler(key, options = {}){\r\n\r\n\t\tlet handler = this.getHandler(key, options);\r\n\t\tif (!handler) return;\r\n\t\tlet { context, args } = options;\r\n\t\treturn handler.apply(context, args);\r\n\r\n\t},\r\n\tgetHandler(key){\r\n\t\tif(_.isFunction(this.handlers[key]))\r\n\t\t\treturn this.handlers[key];\r\n\t},\r\n\tsetHandler(key, handler){\r\n\t\tif(!_.isString(key) || key === '')\r\n\t\t\tthrow new Error('setHandler first argument must be a non empty string');\r\n\r\n\t\tif (!_.isFunction(handler)) {\r\n\t\t\tdelete this.handlers[key];\r\n\t\t} else {\r\n\t\t\tthis.handlers[key] = handler;\r\n\t\t}\r\n\t},\r\n\tsetHandlers(hash){\r\n\t\tlet nullable = hash === null;\r\n\t\tlet items = nullable && this.handlers || hash;\r\n\t\tif(!_.isObject(items)) return;\r\n\t\t_(items).each((handler, key) => this.setHandler(key, nullable || handler));\r\n\t},\r\n\r\n\t// should return hash: { 'handler_key': { context: handler_context, args: handler_arguments}}\r\n\t_getHandleContext(error, context, args = []){\r\n\r\n\t\tif (_.isArray(error)) {\r\n\t\t\treturn _(error).reduce((memo, item) => _.extend(memo, this._getHandleContext(item, context, args)), {});\r\n\t\t}\r\n\r\n\t\tif(_.isFunction(this.getHandleContext)) {\r\n\t\t\tlet custom = this.getHandleContext(error, context, args);\r\n\t\t\tif(custom != null) return custom;\r\n\t\t}\r\n\r\n\t\tif (error instanceof Error) {\r\n\t\t\targs.unshift(error);\r\n\t\t\treturn { 'js:error': { context, args } };\r\n\t\t}\r\n\t\telse if(_.isString(error)) {\r\n\t\t\treturn { [error]: { context, args } };\r\n\t\t}\r\n\t\telse if(error instanceof $.Deferred().constructor){\r\n\t\t\targs.unshift(error);\r\n\t\t\treturn { 'jq:xhr': { context, args }};\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// provide your own arguments processor\r\n\t// should return hash: { 'handler_key': { context: handler_context, args: handler_arguments}}\r\n\tgetHandleContext: undefined,\r\n\r\n};\r\n","import {  getOption, paramsToObject as paramStringToObject } from 'bbmn-utils';\r\nimport { Router as BbRouter } from 'bbmn-core';\r\n\r\n//import paramStringToObject from '../../../utils/params-to-object/index.js';\r\n//import { Backbone, Router as BbRouter } from '../../../vendors/backbone.js';\r\n\r\nimport buildRouteContextFromArguments from './build-route-context.js';\r\n\r\nimport  { createActionContext } from './action-context.js';\r\nimport { processCallback } from './process-callback.js';\r\nimport errorHandler from '../route-error-handler/index.js';\r\n\r\n\r\n\r\nconst Router = BbRouter.extend({\r\n\r\n\r\n\t// for migrating from Mn.AppRoute\r\n\t// set to true. it will populate routes from { controller, appRoutes } structure.\r\n\tisMarionetteStyle: false,\r\n\r\n\t// by default Backbone.Router tries to lookup callback in router instance by name `callback = this[name]` if there is no callback provided\r\n\t// its recomend to turn this feature to false\r\n\t// default value is true for Backbone.Router compatability\r\n\tisRouterHoldsActions : true,\r\n\r\n\t// by default Backbone.Router `route` method returns router itself instead of just created routeContext for chaining purposes.\r\n\t// you can change this behavior turning this feature to false\r\n\tisRouteChaining: true,\r\n\r\n\t//in classic mode actions receive argument array\r\n\t//if you need actionContext instead turn this option to false\r\n\tclassicMode: true,\r\n\r\n\tconstructor(options = {}){\r\n\t\t\r\n\t\tthis.options = _.extend({}, _.result(this, 'options'), options);\r\n\r\n\t\tBbRouter.apply(this, arguments);\r\n\r\n\r\n\t},\r\n\r\n\tgetOption(){\r\n\t\treturn getOption.call(this, ...arguments);\r\n\t},\r\n\r\n\t/*\r\n\r\n\t\tinitialize methods\r\n\t\t\"when a router initialized\"\r\n\r\n\t*/\r\n\r\n\t//by default router expects that routes will result in { route, callback } hash\r\n\t//we are extending this to provide more flexibility\r\n\t// - overrided\r\n\t_bindRoutes: function() {\r\n\t\t\r\n\t\tlet routes = this.getInitRoutes();\r\n\t\tif(!_.size(routes)) return;\r\n\t\tthis.addRoutes(routes);\r\n\r\n\t},\r\n\tgetInitRoutes(){\r\n\t\tlet routes;\r\n\t\tif(this.getOption('isMarionetteStyle')) {\r\n\t\t\tlet controller = this.getOption('controller') || {};\r\n\t\t\tlet approutes = this.getOption('appRoutes') || {};\r\n\t\t\troutes = _(approutes).map((name, route) => ({ \r\n\t\t\t\troute, name, \r\n\t\t\t\tcallback: controller[name] \r\n\t\t\t}));\r\n\t\t}\r\n\t\telse {\r\n\t\t\troutes = this.getOption('routes');\r\n\t\t}\r\n\t\treturn routes;\r\n\t},\r\n\r\n\r\n\t/*\r\n\t\tmanipulating routes\r\n\t\tadding\r\n\t*/\r\n\r\n\t// refactored original route method\r\n\t// chain:true by default is for supporting default behavior\r\n\t// routerHoldsActions: true - backbone router tries to get callback from router itself if there is no callback provided. \r\n\t// this options allow to support this behavior, but its recomended not to hold action inside router instance\r\n\t// - overrided\r\n\troute(route, name, callback, opts = {}){\r\n\t\t\r\n\t\t//normalizing passed arguments and putting them into a context object\r\n\t\t//refactored from original route\r\n\t\t// let context = this._normalizeRegisterRouteArguments(route, name, callback, opts);\r\n\r\n\t\t// //extends context with result of `mergeWithRegisterRouteContext`\r\n\t\t// this._normalizeRegisterRouteContext(context);\r\n\r\n\t\t// //wrapping provided callback \r\n\t\t// this._normalizeRegisterRouteCallback(context);\r\n\r\n\t\tlet context = this._buildRouteContext(route, name, callback, opts);\r\n\r\n\t\t//refactored for providing possibility to override\r\n\t\t//at this point context should be almost ready\r\n\t\tthis.registerRouteContext(context);\r\n\r\n\t\tthis._storeCreatedContext(context, opts);\r\n\r\n\t\treturn opts.isRouteChaining === true \r\n\t\t\t? this \r\n\t\t\t: context;\r\n\r\n\t},\r\n\r\n\t// provide more semantic alias for route\r\n\taddRoute(route, name, callback, opts = {}){\r\n\t\tif(opts.isRouteChaining == null)\r\n\t\t\topts.isRouteChaining = this.getOption('isRouteChaining');\r\n\r\n\t\tlet context = this.route(route, name, callback, opts);\r\n\t\treturn context;\r\n\t},\r\n\r\n\t//process many routes at once\r\n\t//accepts object { name, routeContext | handler }\r\n\t// or array of routeContexts\r\n\taddRoutes(routes, opts = {}){\r\n\r\n\t\tif(opts.isRouteChaining == null)\r\n\t\t\topts.isRouteChaining = this.getOption('isRouteChaining');\r\n\r\n\t\tlet normalized = _(routes)\r\n\t\t\t.chain()\r\n\t\t\t.map((value, key) => this._normalizeRoutes(value, key))\r\n\t\t\t.filter(f => _.isObject(f))\r\n\t\t\t.value();\r\n\r\n\t\tif(opts.doNotReverse != true)\r\n\t\t\tnormalized.reverse();\r\n\r\n\t\tlet registered = _(normalized).map(\r\n\t\t\troute => route && \r\n\t\t\tthis.addRoute(route, _.extend({ massAdd:true }, opts))\r\n\t\t); \r\n\t\t\r\n\t\tif(opts.doNotReverse != true)\r\n\t\t\tregistered.reverse();\r\n\r\n\t\t_(registered).each((c) => this._storeCreatedContext(c));\r\n\t\t\r\n\t\treturn registered;\r\n\t},\r\n\r\n\t// internal method called by `addRoutes` to normalize provided data\r\n\t_normalizeRoutes(value, key){\r\n\t\t//let route, name, callback;\r\n\t\tlet context;\r\n\t\tif (_.isString(value)) {\r\n\t\t\tcontext = { \r\n\t\t\t\troute: key, \r\n\t\t\t\tname: value, \r\n\t\t\t};\r\n\t\t}\r\n\t\telse if(_.isFunction(value)){\r\n\t\t\tcontext = { route:key, callback:value };\r\n\t\t}else if(_.isObject(value)){\r\n\t\t\tcontext = _.clone(value);\r\n\t\t\tif(!_.has(context, 'route'))\r\n\t\t\t\tcontext.route = key;\r\n\t\t\telse if(_.has(context, 'route') && !_.has(context, 'name'))\r\n\t\t\t\tcontext.name = key;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn context;\r\n\t},\r\n\r\n\r\n\r\n\r\n\t_buildRouteContext(route, name, callback, opts) {\r\n\r\n\t\tlet context = buildRouteContextFromArguments(this, route, name, callback, opts);\r\n\r\n\t\treturn this.buildRouteContext(context);\r\n\t},\r\n\r\n\t//override this method if you need more information in route context\r\n\t// should return object wich will be merged with default context\r\n\t// be aware of providing reserved properties: route, name, callback\r\n\t// this will override context defaults\r\n\tbuildRouteContext: context => context,\r\n\r\n\r\n\t//finally, putting handler to the backbone.history.handlers\r\n\tregisterRouteContext(context){\r\n\t\tBackbone.history.route(context.route, context.callbackWrapper, context);\r\n\t},\r\n\r\n\t//store registered context for further use\r\n\t_storeCreatedContext(context, opts = {}){\r\n\t\tthis.routeContexts || (this.routeContexts = {});\r\n\t\tif(!opts.massAdd)\r\n\t\t\tthis.routeContexts[context.name] = context;\r\n\t\treturn context;\r\n\t},\r\n\r\n\r\n\r\n\t/*\r\n\t\r\n\t\tprocess route methods\t\t\r\n\t\t\"when route happens\"\r\n\r\n\t*/\r\n\r\n\t//inner route handler\r\n\t//preparing actionContext and calls public processCallback\r\n\t_processCallback (routeContext, fragment, options = {}) {\r\n\t\tlet actionContext = createActionContext(this, routeContext, fragment, options);\r\n\t\tactionContext.restart = () => actionContext.callbackWrapper(fragment, options);\r\n\t\tlet result = this.processCallback(actionContext, actionContext.routeType, options);\r\n\t\treturn result;\r\n\t},\r\n\t\r\n\t//by default behave as original router\r\n\t//override this method to process action by your own\r\n\tprocessCallback(actionContext, routeType){\r\n\r\n\t\treturn processCallback(this, actionContext, routeType);\r\n\r\n\t},\r\n\r\n\thandleError(error, action){\t\t\r\n\t\terrorHandler.handle(error, this, [action]);\r\n\t},\r\n\r\n\t//just triggers appropriate events\r\n\t// triggerRouteEvents(context, event, name, ...args) {\r\n\t// \tif (event == 'route') {\r\n\t// \t\tthis.lastActionContext = context;\r\n\t// \t}\r\n\t// \tthis.trigger(`${event}:${name}`, ...args);\r\n\t// \tthis.trigger(event, name, ...args);\r\n\t// \tBackbone.history.trigger(event, this, name, ...args);\r\n\t// },\r\n\r\n\ttriggerEvent(event, context){\r\n\t\tthis.trigger(event, context);\r\n\t\tBackbone.history.trigger(event, context);\r\n\t},\r\n\r\n\r\n\r\n\r\n\t//converts string to object\r\n\t//default implementation, can be overriden by user\r\n\tqueryStringParser: paramStringToObject,\t\r\n\r\n\t// navigate(...args){\r\n\t// \thistoryNavigate(...args);\r\n\t// \treturn this;\r\n\t// },\r\n\r\n\t_routeToRegExp(route) {\r\n\r\n\t\tvar optionalParam = /\\((.*?)\\)/g;\r\n\t\tvar namedParam    = /(\\(\\?)?:\\w+/g;\r\n\t\tvar splatParam    = /\\*\\w+/g;\r\n\t\tvar escapeRegExp  = /[-{}[]+?.,\\\\\\^$|#\\s]/g;\r\n\r\n\t\troute = route.replace(escapeRegExp, '\\\\$&')\r\n\t\t\t.replace(optionalParam, '(?:$1)?')\r\n\t\t\t.replace(namedParam, function(match, optional) {\r\n\t\t\t\treturn optional ? match : '([^/?]+)';\r\n\t\t\t})\r\n\t\t\t.replace(splatParam, '([^?]*?)');\r\n\t\tlet flags = this.getOption('routeCaseInsensitive') ? 'i' : '';\r\n\t\treturn new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$', flags);\r\n\t},\r\n\r\n\r\n\t/*\r\n\t\tSome API methods\r\n\t*/\r\n\r\n\tgetContextByFragment(fragment)\t{\r\n\t\tif(!_.isString(fragment)) return;\r\n\t\t//let contexts = this.routeContexts;\r\n\t\t//console.log('Router contexts', contexts);\r\n\t\tlet result = _(this.routeContexts).find((cntx) => cntx.route.test(fragment));\r\n\t\treturn result;\r\n\t}\r\n\r\n\r\n});\r\n\r\nexport default Router;\r\n","import { App } from 'bbmn-components';\r\n\r\nexport default App.extend({\r\n\r\n});\r\n"],"names":["ctors","_","reduce","Model","Collection","BackboneView","Router","MnObject","Region","BaseClass","ctor","isFunction","push","tryGetFromMn","each","ClassName","Mn","isKnownCtor","arg","isFn","result","some","prototype","betterResult","obj","arguments","length","undefined","key","opts","context","args","checkAlso","force","defaultValue","default","isString","value","apply","isObject","alsoOptions","omit","getOption","also","_opts","options","extend","deep","isEmptyValue","_ref","_ref$allowWhiteSpace","allowWhiteSpace","isNaN","trim","pstoSetPair","pair","keyvalue","split","shift","join","pstoSetKeyValue","decodeURIComponent","transform","isArray","paramsToObject","raw","emptyObject","pairs","size","get","router","update","routeArgumentsToObject","route","name","callback","uniqueId","isRouterHoldsActions","rawRoute","isRegExp","_routeToRegExp","callbackWrapper","bind","_processCallback","createActionContext","routeContext","fragment","rawArgs","_extractParameters","slice","queryString","pop","qs","prepareActionQueryString","prepareActionArguments","routeType","queryStringParser","params","match","res","index","substring","concat","toPromise","resolve","Promise","then","Error","reject","getCallbackFunction","executeResult","exception","promise","processCallback","actionContext","asPromise","triggerEvent","shouldTriggerEvent","execute","lastAttempt","error","handleError","handlers","_getHandleContext","applyHandler","handler","getHandler","hash","nullable","items","setHandler","memo","item","getHandleContext","custom","unshift","$","Deferred","constructor","BbRouter","call","routes","getInitRoutes","addRoutes","controller","approutes","map","_buildRouteContext","registerRouteContext","_storeCreatedContext","isRouteChaining","normalized","chain","_normalizeRoutes","filter","f","doNotReverse","reverse","registered","addRoute","massAdd","c","clone","has","buildRouteContextFromArguments","buildRouteContext","history","routeContexts","restart","action","handle","event","trigger","paramStringToObject","optionalParam","namedParam","splatParam","escapeRegExp","replace","optional","flags","RegExp","find","cntx","test","App"],"mappings":"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"}